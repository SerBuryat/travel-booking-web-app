Рефакторинг слоёв repository/ и service/ в стиле feature-first + упрощение API

Контекст: текущие `src/repository/**` и `src/service/**` — смесь типов и методов без чётких границ. Нужно привести к простому, читаемому стилю по примеру `src/repository/AreaRepository.ts` и `src/service/AreaService.ts`, а также руководствоваться подходом Feature-First (как в `src/lib/auth/user-auth.ts`), решая одну бизнес-задачу за раз и вынося общий код после.

Цели:
- Простые, узкие интерфейсы репозиториев и сервисов
- Минимум типов/деталей вне контекста фичи
- Ясная зависимость: сервис использует 1–2 репозитория, каждая функция делает одно

Что сделать:
- [ ] Провести инвентаризацию методов в `src/repository/**` и сгруппировать по фичам (domain use-cases)
- [ ] Для каждой фичи определить минимальный публичный API сервиса (2–5 операций), остальное — внутренние helpers
- [ ] Привести репозитории к лаконичному стилю как `AreaRepository` (без лишней логики — только доступ к БД)
- [ ] Привести сервисы к стилю как `AreaService` (тонкий слой, бизнес-логика без знания БД)
- [ ] Вынести общие функции (валидации, мапперы, типы) в локальные модули фичи; только реально общие — в `lib/` или `shared/`
- [ ] Навести порядок в типах: убрать «утечки» БД-типов наружу, отдавать сущности/DTO стабильной формы
- [ ] Удалить или переразбить «большие» сервисы на несколько feature-сервисов

Критерии приёмки:
- Каждый сервис и репозиторий имеет небольшой и понятный публичный API
- Нету смешения слоёв: репозитории не знают бизнес-правил, сервисы не знают деталей БД
- Файлы упорядочены по фичам (feature-first); навигация по коду проще
- Тесты на ключевые кейсы проходят, регрессий нет

Подсказки:
- Сначала оформлять фичу (use-case) как в `user-auth.ts`, затем выделять общие части
- Следовать именованию, понятному продукту (не только БД)

