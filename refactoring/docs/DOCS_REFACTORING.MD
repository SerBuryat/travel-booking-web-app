# DOCS_REFACTORING.MD

## Связь артефактов

- **Главный артефакт:** `refactoring/REDACTORING.MD`
- **Этот документ:** план по документации, комментариям и README.

---

## 1. Цели документационного рефакторинга

- Сделать код **самодокументируемым**, но при этом иметь минимум явной, но полезной документации.
- Обеспечить, чтобы ключевые функции/модули были понятны **без погружения во всю кодовую базу**.
- Подготовить проект к работе с агентами/ИИ и новыми разработчиками.

---

## 2. README.md

### 2.1. Цели

- Дать новому человеку (или агенту) возможность за 5 минут понять:
  - что делает проект,
  - как он устроен архитектурно,
  - как его запустить,
  - где искать артефакты рефакторинга.

### 2.2. Структура целевого README

1. **Описание проекта**
   - Кратко: что за продукт (travel booking / маркетплейс услуг).
2. **Технологический стек**
   - Next.js (App Router), TypeScript, Prisma, Telegram API, TailwindCSS.
3. **Архитектура**
   - Feature-layered, краткое описание `src/lib/<feature>/**`.
   - Связь фронта (`src/app/**`, `src/components/**`, `src/hooks/**`) и бэка (`src/lib/**`).
4. **Структура папок**
   - Табличка/список с основными директориями и их назначением.
   - Отдельный пункт: `refactoring/` и его роль.
5. **Запуск проекта**
   - Локальный запуск (env, `npm install`, `npm run dev`).
   - Docker (если актуально).
6. **Рефакторинг и артефакты**
   - Краткое описание `REDACTORING.MD`.
   - Ссылки на фронт/бэк/AI/доки.

---

## 3. Документация функций (JSDoc / TSDoc)

### 3.1. Где документировать

- Все **экспортируемые** функции и хуки:
  - из `src/lib/**`,
  - из `src/hooks/common/**`,
  - из общих компонентов/утилит, если там есть нетривиальная логика.

### 3.2. Минимальный формат

```typescript
/**
 * [functionName] Краткое описание функции.
 *
 * Подробности (по необходимости).
 *
 * @param {Type} paramName - Описание параметра.
 * @returns {Promise<ReturnType>} Описание возвращаемого значения.
 * @throws {Error} Условия, при которых выбрасывается ошибка.
 */
export async function functionName(paramName: Type): Promise<ReturnType> {
  // ...
}
```

### 3.3. Приоритеты

1. Функции, реализующие **бизнес-процессы**:
   - создание/редактирование сервисов,
   - создание заявок и предложений,
   - авторизация и Telegram-интеграция.
2. Функции, вызываемые из **нескольких мест**.
3. Публичные API модулей `src/lib/<feature>/types.ts`.

---

## 4. Комментарии в коде

### 4.1. Принципы

- Не комментировать очевидное (например, простые сеттеры/геттеры).
- Комментарии нужны там, где:
  - есть неочевидный бизнес-решение,
  - есть важные ограничения/инварианты,
  - логика связана с внешними API (Telegram, S3 и т.п.).

### 4.2. Где особенно полезны комментарии

- В местах, где:
  - выполняются транзакции Prisma с несколькими шагами,
  - реализованы сложные проверки ролей/прав доступа,
  - есть нетривиальные алгоритмы (сортировки, фильтры, агрегации).

---

## 5. Инкапсуляция длинных функций

**См. раздел 4.3 в `REDACTORING.MD`.**

Цель этого артефакта — отслеживать прогресс:

- какие длинные функции уже разбиты,
- какие ещё нужно трогать.

Рекомендуется вести список проблемных мест (по мере нахождения) прямо в этом файле:

- [ ] `src/lib/provider/servicesEdit.ts > updateService` — разбить на подфункции.
- [ ] ... (добавлять по мере анализа).

---

## 6. Связь с другими артефактами

- **Общий план:** `refactoring/REDACTORING.MD`
- **Фронтенд:** `refactoring/frontend/FRONTEND_REFACTORING.MD`
- **Бэкенд:** `refactoring/backend/BACKEND_REFACTORING.MD`
- **Cursor/AI:** `refactoring/cursor-ai/CURSOR_AI_REFACTORING.MD`

Этот файл описывает, **как документировать** уже спроектированную архитектуру и рефакторинг.


